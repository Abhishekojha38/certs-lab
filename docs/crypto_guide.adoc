:imagesdir: ../images

= Crypto Lab
Abhishek Ojha <Abhishekojha38@gmail.com.com>
:toc:
:toclevels: 3
:icons: font
:sectnums:

== Introduction

Brief overview of what this guide covers:

* Key generation (RSA)
* Understand digital signature
* X.509 certificates (self-signed & CA-signed)

== Environment Setup

List prerequisites:

* OpenSSL â‰¥ 3.0
* asciidoctor for rendering

Example setup:
[source,bash]
----
sudo apt install openssl asciidoctor
----

== Key Generation

* Generate Private key:

[source,bash]
----
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
cat private_key.pem 
----

----
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCkUrjpLeCnuXXE
........
........
mMzOBHNsW8pIxInMBcUp3NM=
-----END PRIVATE KEY-----
----

* Extract Public Key:

[source,bash]
----
openssl rsa -pubout -in private_key.pem -out public_key.pem
cat public_key.pem
----

----
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApFK46S3gp7l1xJ7dzWnu
........
MF4fIkaSMeeXXxoDwamJvZrXqWR37QlzV+WRlCoHY5tWGTEhsKXmrvD7Yh0WNkP+
rQIDAQAB
-----END PUBLIC KEY-----
----

== Understanding digital signature

* Steps for Computing a Digital Signature:
- `Generate a Key Pair`: Create a public and private key pair using a key generation
algorithm, such as RSA.
- `Prepare the Data`: Identify the data for which the signature will be computed.
- `Compute the Hash`: Generate a hash of the data using a hashing algorithm, for
example, SHA-256.
- `Encrypt the Hash`: Encrypt the computed hash with the private key. The result
of this encryption is the digital signature.

image::digital_signature_generation.png[Digital Signature Flow, align=center, width=500]

* Steps for Verifying a Digital Signature
- `Gather Required Information`: To verify a signature,  data that was signed,
the digital signature, the hash algorithm used, and the signerâ€™s public key.
- `Compute the Data Hash`: Generate the hash of the received data using the same
hashing algorithm that was used to create the signature (e.g., SHA-256).
- `Decrypt the Signature`: Use the public key to decrypt the digital signature.
This will yield the hash value that was originally computed during signing.
- `Compare Hashes`: Compare the hash obtained from the data with the hash obtained
from decrypting the signature.
- If the hashes match, the signature is valid and the data has not been tampered
with.
- If the hashes do not match, the data may have been altered, and the signature is
invalid.

image::digital_signature_verification.png[Digital Signature Flow, align=center, width=600]

A digital signature is a cryptographic method that ensures:

* `Authenticity`: Confirms the source of data.
* `Integrity`: Ensures the data hasnâ€™t been modified.
* `Non-repudiation`: Prevents the signer from denying authorship.

`A Private Key` â†’ used to sign data.
`A Public Key` â†’ used to verify the signature.

=== Signing Process

The sender takes the original data.

* A hash function (e.g., SHA-256) is applied to produce a fixed-length digest.
* This hash is then encrypted with the senderâ€™s private key â†’ producing the digital signature.
* The signature is sent along with the data.

----
Data â”€â”€> Hash â”€â”€> Encrypt with Private Key â”€â”€> Digital Signature
----

==== Example

* Sample data.

[source,bash]
----
echo "Confidential data to sign" > data.txt
----

* Sign the data and generate digital signature.

[source,bash]
----
openssl dgst -sha256 -sign private_key.pem -out signature.bin data.txt
----

* Verify signature.

[source,bash]
----
openssl dgst -sha256 -verify public_key.pem -signature signature.bin data.txt
----

=== Ways to store a digital signature:

* Raw Binary Format:

[source,bash]
----
openssl dgst -sha256 -sign private_key.pem -out signature.bin data.txt
----

* PEM Format:

[source,bash]
----
openssl dgst -sha256 -sign private_key.pem -out signature.bin data.txt
openssl base64 -in signature.bin -out signature.pem
----

----
-----BEGIN SIGNATURE-----
MEYCIQC1...
-----END SIGNATURE-----
----

* PKCS#7 / CMS (Cryptographic Message Syntax)

----
SignedData {
  version,
  digestAlgorithms,
  encapContentInfo,
  certificates,        <-- X.509 cert(s)
  crls OPTIONAL,
  signerInfos          <-- Signature + metadata
}
----

[source,bash]
----
openssl smime -sign -in data.txt -signer cert.pem -inkey key.pem -outform DER \
-out signature.p7s
----

* PKCS#10 / X.509 Containers

[source,bash]
----
openssl req -newkey rsa:2048 -keyout private_key.pem -x509 -days 365 -out cert.pem
----

== Chain of trust

Each certificateâ€™s signature can be verified using the public key of the issuer
above it.

* The server certificate is verified by the intermediateâ€™s public key.
* The intermediate certificate is verified by the root CAâ€™s public key.
* The root CA is trusted because your OS or browser already trusts it.

----
Root CA â†’ Intermediate CA(s) â†’ End-Entity (Server) Certificate
----

----
+------------------------+
| Root CA Certificate    |
| (self-signed, trusted) |
+-----------â–²------------+
            |
            | signs
            â–¼
+-----------------------------+
| Intermediate CA Certificate |
| (signed by Root CA)         |
+-----------â–²-----------------+
            |
            | signs
            â–¼
+--------------------------------+
| End-Entity / Server Certificate|
| (www.example.com)              |
+--------------------------------+
----

When the server sends its cert chain to the client, it includes the bottom two:
----
[Server Cert] + [Intermediate Cert(s)]
----

[NOTE]
--
The intermediate certificate (Intermediate CA) exists for security, flexibility,
and scalability
--

* `Root CAs` Are Extremely Sensitive. So we don't want to expose the private key
and that the reason `Intermediate cert` came in picture.

* `Intermediate Certificates` Act as a â€œBufferâ€.Root CA delegates the signing
authority to one or more Intermediate CAs.These intermediates then sign
end-entity (server) certificates.

** Limits exposure of root private key
** Easier key rotation

=== Example

* Create following certs to undertand the chain of trust.

----
certs/
  root/
    root.key.pem
    root.crt.pem
  intermediate/
    intermediate.key.pem
    intermediate.crt.pem
  server/
    server.key.pem
    server.csr.pem
    server.crt.pem
----

* Generate Root CA - self signed

[source,bash]
----
# 2.1 Generate root private key
openssl genrsa -out certs/root/root.key.pem 4096

# 2.2 Generate self-signed root certificate (valid 10 years)
openssl req -x509 -new -nodes -key certs/root/root.key.pem \
  -sha256 -days 3650 \
  -out certs/root/root.crt.pem \
  -subj "/C=US/ST=CA/L=SanFrancisco/O=ExampleRootCA/OU=RootCA/CN=ExampleRootCA"

----

* Generate the Intermediate CA

[source,bash]
----
# 3.1 Generate intermediate private key
openssl genrsa -out certs/intermediate/intermediate.key.pem 4096

# 3.2 Generate CSR (Certificate Signing Request) for intermediate
openssl req -new -key certs/intermediate/intermediate.key.pem \
  -out certs/intermediate/intermediate.csr.pem \
  -subj "/C=US/ST=CA/L=SanFrancisco/O=ExampleIntermediateCA/OU=Intermediate/CN=ExampleIntermediateCA"

# 3.3 Sign the intermediate CSR with Root CA
openssl x509 -req -in certs/intermediate/intermediate.csr.pem \
  -CA certs/root/root.crt.pem -CAkey certs/root/root.key.pem -CAcreateserial \
  -out certs/intermediate/intermediate.crt.pem -days 1825 -sha256

----
Now you have an Intermediate CA signed by the Root CA.

* Generate the Server (End-Entity) Certificate

[source,bash]
----
# 4.1 Generate server private key
openssl genrsa -out certs/server/server.key.pem 2048

# 4.2 Generate server CSR
openssl req -new -key certs/server/server.key.pem \
  -out certs/server/server.csr.pem \
  -subj "/C=US/ST=CA/L=SanFrancisco/O=ExampleServer/OU=Web/CN=www.example.com"

# 4.3 Sign server CSR with Intermediate CA
openssl x509 -req -in certs/server/server.csr.pem \
  -CA certs/intermediate/intermediate.crt.pem -CAkey certs/intermediate/intermediate.key.pem -CAcreateserial \
  -out certs/server/server.crt.pem -days 825 -sha256
----

* Verify the Chain

[source,bash]
----
# Verify the server cert against the chain
openssl verify -CAfile <(cat certs/root/root.crt.pem certs/intermediate/intermediate.crt.pem) \
  certs/server/server.crt.pem
----

* Optional: Create PKCS#7 Bundle
----
openssl crl2pkcs7 -nocrl -certfile certs/server/server.crt.pem \
  -certfile certs/intermediate/intermediate.crt.pem -out certs/server/server.p7b \
  -certfile certs/root/root.crt.pem
----

== Understanding X509 Certificate

An X.509 certificate is a digital document that binds a public key to an
identity (like a user, computer, or server) and is used to verify authenticity
and enable secure communication. These certificates are a standard part of
Public Key Infrastructure (PKI), are issued by trusted Certificate Authorities
(CAs).


There are two common types:

* `Root CA Certificate` â€” A trusted Certificate Authority used to sign other
certificates.
* `Self-Signed Certificate` â€” A standalone certificate signed by its own private
key (used when no CA is involved).

=== Generate self-signed X509

* Generate Private key

[source,bash]
----
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
----

* Now there are two steps to genearte self-signed X509.
** Using -x509 option of openssl: You get a self-signed certificate in one step.
** Generate csr and then sign it with same private key which was used for csr.
  -x509 option also does same thing in the background.

==== Option 1: Using -x509 option

Generate self-signed x509 certificate.

* Creates a new certificate request internally.
* Immediately self-signs it using the same private key.
* Outputs the certificate (X.509 format), not the CSR.

[source,bash]
----
$ openssl req -x509 -new -nodes -key private_key.pem -sha256 -days 3650 -out device.crt
----
----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
Country Name (2 letter code) [AU]:CA
State or Province Name (full name) [Some-State]:Quebec
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Company Solutions
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:device.company.solutions
Email Address []:
----

[[generate-csr]]
==== Option 2: Generate csr and then sign it with same private key.

* You explicitly create a Certificate Signing Request (CSR).
* Then you use openssl x509 to sign that CSR using the same private key.
* The result is a self-signed certificate, just like in `Option 1` â€” but via two
steps.

* Generate CSR, Hash of (Public Key + Identity Info) = Sign the Hash with
Private key which result in Digital signature. Append digital signature at the
end of CSR.

[source,bash]
----
$ openssl req -new -key private_key.pem -out request.csr
----
----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
Country Name (2 letter code) [AU]:CA
State or Province Name (full name) [Some-State]:Quebec
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Company Solutions
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:device.company.solutions
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
----

* Generate X509 cert.

[source,bash]
----
openssl x509 -req -in request.csr -signkey private_key.pem -out cert.pem -days 365
----
----
Certificate request self-signature ok
subject=C=CA, ST=Quebec, O=Company Solutions, CN=device.company.solutions
----

=== Generate X509 Root CA

==== Create a Root CA Certificate

A Root CA is the top of the trust chain â€” it signs other certificates to make
them trusted.

* Generate Root CA Private Key.

[source,bash]
----
openssl genpkey -algorithm RSA -out root-pri.key -pkeyopt rsa_keygen_bits:4096
----

* Create Root CA Certificate.

[source,bash]
----
$ openssl req -x509 -new -nodes -key root-pri.key -sha256 -days 3650 -out rootCA.crt
----
----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
Country Name (2 letter code) [AU]:CA
State or Province Name (full name) [Some-State]:Quebec
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:ROOTCA 
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
----

[NOTE]
--
- -x509: Create a self-signed certificate (no CSR required).
- -days 3650: Valid for 10 years.
- -sha256: Use SHA-256 for signing.
--

* Verify Root CA Certificate. We can clearly see Data, Signature algo, Signature
(Data â”€â”€> Hash â”€â”€> Encrypt with Private Key â”€â”€> Digital Signature). Here
Encrypt with Private Key(Hash(data(Identitiy + PublicKey))) is
sha256WithRSAEncryption(data(Identitiy + PublicKey))

[source,bash]
----
openssl x509 -in rootCA.crt -text -noout
----
----
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            04:43:12:87:22:c4:dd:82:2e:0b:9c:ee:fa:c5:0a:a5:73:eb:19:e5
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd
        Validity
            Not Before: Oct 17 14:00:58 2025 GMT
            Not After : Oct 15 14:00:58 2035 GMT
        Subject: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (4096 bit)
                Modulus:
                    00:b8:f3:eb:32:6d:95:5c:42:db:04:e5:12:c4:0d:
                    da:4c:8a:ee:44:45:9a:8c:73:b4:91:a6:80:9e:f4:
                    .........
                    16:d1:bb:e3:8a:d0:3c:12:62:a9:e4:85:ad:e2:62:
                    b0:82:63
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                E2:D7:F6:CF:B9:96:2C:A9:DF:75:04:20:4D:CD:B3:F9:AC:20:44:38
            X509v3 Authority Key Identifier: 
                E2:D7:F6:CF:B9:96:2C:A9:DF:75:04:20:4D:CD:B3:F9:AC:20:44:38
            X509v3 Basic Constraints: critical
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        53:f5:56:db:7d:ca:1d:96:62:15:ed:68:2d:38:9e:74:4b:7c:
        .............
        7a:81:48:62:26:b5:74:49:b5:aa:17:e6:e1:a1:ff:c6:e2:df:
        3a:11:96:45:38:b5:8b:f9
----

=== Create a Device Certificate Signed by Root CA

Now weâ€™ll create another certificate (for a device, web server, or user) thatâ€™s
signed by the Root CA.

image::swupdate_cms_1.png[Digital Certificate Flow, align=center, width=800]

* Generate Device Private Key.

[source,bash]
----
openssl genpkey -algorithm RSA -out device.key -pkeyopt rsa_keygen_bits:2048
----

* Generate CSR (Certificate Signing Request)
Hash of (Public Key + Identity Info) = Sign the Hash with Private key which
result in Digital signature. Append digital signature at the end of CSR.

[source,bash]
----
$ openssl req -new -key device.key -out device.csr
----
----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
Country Name (2 letter code) [AU]:
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
----

Enter details:

----
Country Name (2 letter code) [AU]:CA
State or Province Name (full name) [Some-State]:Quebec
Organization Name [Internet Widgits Pty Ltd]:Company Solutions
Common Name [localhost]:device.company.local
----

* Dump csr for understanding.

[source,bash]
----
openssl req -in device.csr -text -noout
----
----
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: C = AU, ST = Some-State, O = Internet Widgits Pty Ltd
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:c0:9e:7d:ed:6e:4d:22:da:b2:5a:a6:cd:06:9a:
                    78:4c:f9:4e:56:2e:d0:8c:68:42:aa:cd:31:cf:4b:
                    .............
                    9f:77:e1:29:10:c0:8a:50:c1:f7:86:6e:37:ed:71:
                    ab:3f
                Exponent: 65537 (0x10001)
        Attributes:
            (none)
            Requested Extensions:
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        7e:f0:a0:94:c1:38:98:82:59:d1:26:3f:a3:4c:90:a3:86:ba:
        .........
        0c:34:31:0c:78:75:17:9d:ab:24:00:f2:8d:92:32:bb:29:dc:
        46:95:0b:ec
----

* Create Configuration File for Extensions (Optional but Recommended).

----
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = device.company.local
----

* Sign the Device CSR with Root CA.

[source,bash]
----
openssl x509 -req -in device.csr -CA rootCA.crt -CAkey root-pri.key -CAcreateserial \
-out device.crt -days 730 -sha256 -extfile device_ext.cnf
----
----
Certificate request self-signature ok
subject=C = CA, ST = Quebec, O = Company Solutions, CN = device.company.local
----

* Verify the Signed Certificate.

[source,bash]
----
openssl x509 -in device.crt -text -noout
----

* Verify the Certificate Chain.

[source,bash]
----
$ openssl verify -CAfile rootCA.crt device.crt
----
----
device.crt: OK
----

== Encoding Formats

=== PEM

* ASCII Base64 encoding format.
* PEM certificates can have a file extension of .pem, .crt, or .cer.
* The PEM format is the most common format that Certificate Authorities issue
certificates in.
* PEM certificates usually have extentions such as .pem, .crt, .cer, and .key.
* They are Base64 encoded ASCII files and contain "-----BEGIN CERTIFICATE-----"
and "-----END CERTIFICATE-----" statements.
* Server certificates, intermediate certificates, and private keys can all be
put into the PEM format.
* The PKCS12 format is preferred for exchanging certificates that has private
key(s).

----
-----BEGIN CERTIFICATE-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...
-----END CERTIFICATE-----
----

=== DER

* The DER format is simply a binary form of a certificate instead of the
ASCII PEM format.
* It sometimes has a file extension of .der but it often has a file extension
of .cer so the only way to tell the difference between a DER .cer file and a
PEM .cer file is to open it in a text editor and look for the BEGIN/END
statements.
* All types of certificates and private keys can be encoded in DER format.

=== PKCS#5

* Password-Based Encryption Standard.
* Protecting private keys with passwords.
* Replaced by `PKCS#12` (which is more general) and `PKCS#8` for key storage.
http://tools.ietf.org/html/rfc2898[RFC2898]

=== PKCS#8

* Standard syntax for storing private keys.
* It Can be encrypted or unencrypted. 

----
Unencrypted:
-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----

Encrypted:
-----BEGIN ENCRYPTED PRIVATE KEY-----
...
-----END ENCRYPTED PRIVATE KEY-----
----

[NOTE]
--
PKCS#8 is a private key syntax for all algorithms and not just RSA. On the
other hand, PKCS#1 is primarily for using the RSA algorithm.
--

=== PKCS#10

* Certificate Signing Request (CSR) format. Refer to the
<<generate-csr,generate csr>> section.

----
-----BEGIN CERTIFICATE REQUEST-----
...
-----END CERTIFICATE REQUEST-----
----

=== PKCS#11

* Defines a platform-independent API known as `Cryptoki`
(â€œCryptographic Token Interfaceâ€).
* It allows applications to interact with cryptographic tokens â€” such as
Hardware Security Modules (HSMs), smart cards,or TPMs, OP-TEE.

PKCS#11 Module is a Module that has an API for accessing Crypto Hardware such
as HSM (Hardware Security Module), Smart Card, and Crypto Tokens
(e.g., USB Token), and it is an S/W Library provided by H/W Vendor. It is also
called Cryptoki Module, and Cryptoki is a character made by shortening the
Cryptographic Token Interface.

A `slot` represents a connection point where a token can be present.
ðŸ§  Think of a slot as the â€œreader.â€

----
Slot 0 â€” Smart card reader
Slot 1 â€” Software token (SoftHSM)
----

A `token` is the actual cryptographic module inserted into a slot.
ðŸ§  Think of the token as the â€œsmart cardâ€ or â€œHSM chipâ€ that does crypto operations.

----
Token Label: â€œSecureKeyStoreâ€
Manufacturer: â€œOsmosis Security HSMâ€
Serial Number: 123456
----

An `object` is a data item stored on a token.
ðŸ§  Think of an object as the â€œfileâ€ or â€œrecordâ€ stored inside the token.

There are different types of objects:

* Data objects â†’ arbitrary user data
* Key objects â†’ private, public, or secret keys
* Certificate objects â†’ X.509 certs

==== PKCS#11 with OP-TEE

* List available slots.

[source,bash]
----
pkcs11-tool --module /usr/lib/libckteec.so -L
----

----
Available slots:
Slot 0 (0x0): OP-TEE PKCS#11 Token (User)
  token label        : OP-TEE Token
  token manufacturer : Linaro
  token model        : OP-TEE
  serial num         : 0000000000000000
  flags              : login required, rng, token initialized

----

* Initialize token (first time only) and pin.

[source,bash]
----
pkcs11-tool --module /usr/lib/libckteec.so --init-token --label "TEE-Token"
pkcs11-tool --module /usr/lib/libckteec.so --init-pin --pin 1234
----

* Generate RSA key pair inside secure enclave.

[source,bash]
----
pkcs11-tool --module /usr/lib/libckteec.so \
  --login --pin 1234 \
  --keypairgen --key-type RSA:2048 --id 01 --label "TEE-RSA-Key"
---- 

* After generating the key list the URI.

[source,bash]
----
pkcs11-tool --module /usr/lib/libckteec.so --list-objects --login --pin 1234 \
--type privkey --output-format pkcs11
----
----
pkcs11:token=TEE-Token;object=TEE-RSA-Key;id=%01;type=private
----

* Now you can use it directly with openssl.

[source,bash]
----
openssl pkeyutl -sign \
  -engine pkcs11 \
  -keyform engine \
  -inkey 'pkcs11:token=TEE-Token;id=%01;type=private' \
  -in data.txt -out sig.bin
----

* List the objects.

[source,bash]
----
pkcs11-tool --list-slots --module /usr/lib/libckteec.so.0 --login \
--pin 12345678 --list-objects
----
----
Available slots:
Slot 0 (0x0): OP-TEE PKCS11 TA - TEE UUID 55630e1a-0f9a-58e6-bf33-4cecc7d0b897
  token label        : optee
  token manufacturer : Linaro
  token model        : OP-TEE TA
  token flags        : login required, rng, SO PIN count low, token initialized, PIN initialized
  hardware version   : 0.0
  firmware version   : 0.1
  serial num         : 0000000000000000
  pin min/max        : 4/128
Slot 1 (0x1): OP-TEE PKCS11 TA - TEE UUID 55630e1a-0f9a-58e6-bf33-4cecc7d0b897
  token state:   uninitialized
Slot 2 (0x2): OP-TEE PKCS11 TA - TEE UUID 55630e1a-0f9a-58e6-bf33-4cecc7d0b897
  token state:   uninitialized
Using slot 0 with a present token (0x0)
Secret Key Object; AES length 32
  label:      -aes-key
  ID:         cafebabe
  Usage:      encrypt, decrypt
  Access:     none
----

Make the `Cryptoki API` available to Linux user-space applications:

* Uses the `ckteec` library, which is licensed under the 2-clause BSD license
and available in `optee_client.git`.
* Translates `Cryptoki API` calls into messages that invoke TA commands and
arguments in a GPD TEE.

The `PKCS#11` token is implemented as an `OP-TEE` Trusted Application (TA):

* Uses `GPD TEE APIs` for secure storage and cryptography.
* Fully implements the PKCS#11 specification.
* Licensed under the 2-clause BSD license and available in optee_os.git.


=== PKCS#12

* Container format for storing private key + certificate chain.
* It is used to bundle a private key with its X.509 or to bundle all the members
of a chain of trust.

[source,bash]
----
openssl pkcs12 -export -out bundle.p12 -inkey private.key -in cert.crt \
-certfile ca.crt
----

=== PKCS#7
* PKCS#7 defines a general syntax for cryptographic messages such as signed
data, encrypted data, digested data, or authenticated data.

Itâ€™s used in:
- S/MIME (secure email)
- Certificate bundles
- Code signing
- Firmware update packages

==== Sign message PKCS#7

It is necessary to know how digital signatures are produced and verified, before
moving on to PKCS#7 SignedData.

* Generate a private key and certificate.

[source,bash]
----
openssl genrsa -out private.key 2048
openssl req -x509 -new -key private.key -out cert.pem -days 365 \
  -subj "/C=US/ST=CA/L=SanJose/O=Osmosis Solutions/CN=example.com"
----

* Create a message file

[source,bash]
----
echo "Hello, this is a PKCS#7 signing example." > message.txt
----

* Sign the message using PKCS#7 (CMS)

[source,bash]
----
openssl smime -sign \
  -in message.txt \
  -signer cert.pem \
  -inkey private.key \
  -out signed.p7s \
  -outform PEM
----

[NOTE]
--
If you want only the signature (detached), use -nodetach
--

[source,bash]
----
openssl smime -sign -in message.txt -signer cert.pem -inkey private.key \
  -out signed.p7s -outform PEM -nodetach
----

* View the signed message structure

[source,bash]
----
openssl pkcs7 -in signed.p7s -print_certs -text -noout
----
----
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            78:3c:3a:b0:3a:59:89:eb:3a:a8:17:2b:88:19:79:c2:86:06:f7:04
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=US, ST=CA, L=SanJose, O=Osmosis Solutions, CN=example.com
        Validity
            Not Before: Oct 22 03:09:00 2025 GMT
            Not After : Oct 22 03:09:00 2026 GMT
        Subject: C=US, ST=CA, L=SanJose, O=Osmosis Solutions, CN=example.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:d1:6b:93:66:7c:0b:12:d0:48:22:2b:fa:0b:50:
                    ......
                    91:89
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Subject Key Identifier: 
                72:53:8E:21:60:0E:58:F9:D1:0C:5D:78:4D:C6:92:92:49:20:E5:4D
            X509v3 Authority Key Identifier: 
                72:53:8E:21:60:0E:58:F9:D1:0C:5D:78:4D:C6:92:92:49:20:E5:4D
            X509v3 Basic Constraints: critical
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        0b:11:0e:bc:c8:c7:2a:8a:fb:ad:1b:62:a9:b0:1d:65:8d:d0:
        ....
        92:0e:b0:10

----

* Verify the signature

[source,bash]
----
openssl smime -verify \
  -in signed.p7s \
  -inform PEM \
  -content message.txt \
  -noverify \
  -out verified.txt
----

[cols="1,2,2,2,1", options="header"]
|===
| Format / Standard | Purpose | Contains | Common Extension | Encoding

| PEM
| General container
| Certs / Keys
| .pem, .crt, .key
| Base64

| DER
| Binary form
| Certs / Keys
| .der, .cer
| Binary

| PKCS#5
| Password-based key derivation
| â€”
| â€”
| â€”

| PKCS#8
| Private key format
| Private key
| .p8, .key
| PEM/DER

| PKCS#10
| Certificate Signing Request
| CSR info + signature
| .csr
| PEM/DER

| PKCS#12
| Key + certificate chain container
| Private key + certs
| .p12, .pfx
| Binary

| PKCS#7 (CMS)
| Signed/encrypted message or cert chain. *Uses private key for signing but does not contain it.*
| Certs, signatures, encrypted data
| .p7b, .p7c
| Binary/PEM
|===

== Refrences
* https://datatracker.ietf.org/doc/html/rfc2898
* https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/
* https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs
* https://www.cem.me/20150104-cert-binaries-2.html
* https://static.linaro.org/connect/lvc21/presentations/lvc21-215.pdf
